{% extends "base.html" %}

{% block title %}Home - Goswami Whisper{% endblock %}

{% block extra_css %}
<style>
    .upload-table th, .upload-table td {
        vertical-align: middle;
    }
    .child-table {
        background-color: #f8f9fa;
        margin-left: 30px;
    }
    .indexed-row {
        background-color: #d4edda !important;
    }
    .has-indexed-child {
        background-color: #e8f5e9 !important;
    }
    .expand-btn {
        cursor: pointer;
        width: 24px;
    }
    .expand-btn i {
        transition: transform 0.2s;
    }
    .expand-btn.expanded i {
        transform: rotate(90deg);
    }
    .nested-table {
        display: none;
    }
    .nested-table.show {
        display: table-row;
    }
    .progress-container {
        min-width: 100px;
    }
    .action-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
    }
    .modal-lg-custom {
        max-width: 700px;
    }
    .status-pending { color: #6c757d; }
    .status-processing { color: #ffc107; }
    .status-completed { color: #28a745; }
    .status-error { color: #dc3545; }
    .streaming-text {
        white-space: pre-wrap;
        font-family: monospace;
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 0.5rem;
        max-height: 400px;
        overflow-y: auto;
    }
    .search-highlight {
        background-color: #fff3cd;
        padding: 0.1rem 0.2rem;
        border-radius: 0.2rem;
    }
    /* Diff highlighting styles */
    .diff-added {
        background-color: #d4edda;
        color: #155724;
    }
    .diff-removed {
        background-color: #f8d7da;
        color: #721c24;
    }
    .compare-btn {
        cursor: pointer;
        transition: all 0.2s;
    }
    .compare-btn.selected {
        box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.5);
    }
    .compare-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        overflow: hidden;
    }
    .compare-panel-header {
        background: #f8f9fa;
        padding: 0.5rem 1rem;
        border-bottom: 1px solid #dee2e6;
        font-weight: bold;
        font-size: 0.85rem;
        flex-shrink: 0;
    }
    .compare-panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        font-family: monospace;
        font-size: 0.85rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.6;
        background: #fff;
    }
    .compare-panel-content .diff-added {
        background-color: #d4edda;
        color: #155724;
    }
    .compare-panel-content .diff-removed {
        background-color: #f8d7da;
        color: #721c24;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <!-- Search Results (hidden by default) -->
    <div class="col-12 mb-4" id="searchResults" style="display: none;">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0"><i class="bi bi-search me-2"></i>Search Results</h5>
                <button class="btn btn-sm btn-outline-secondary" id="clearSearch">
                    <i class="bi bi-x"></i> Clear
                </button>
            </div>
            <div class="card-body" id="searchResultsBody">
                <!-- Search results will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Uploads Table -->
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    <i class="bi bi-files me-2"></i>All Uploads
                </h5>
                <div class="d-flex gap-2">
                    <div class="input-group" style="max-width: 250px;">
                        <input type="text" class="form-control form-control-sm" id="searchInput"
                               placeholder="Search transcriptions...">
                        <button class="btn btn-outline-light btn-sm" type="button" id="searchBtn">
                            <i class="bi bi-search"></i>
                        </button>
                    </div>
                    <button class="btn btn-light btn-sm" data-bs-toggle="modal" data-bs-target="#uploadModal">
                        <i class="bi bi-upload me-1"></i> Upload
                    </button>
                    <button class="btn btn-outline-light btn-sm" id="refreshBtn">
                        <i class="bi bi-arrow-clockwise"></i>
                    </button>
                </div>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-hover upload-table mb-0">
                        <thead class="table-light">
                            <tr>
                                <th style="width: 30px;"></th>
                                <th>Filename</th>
                                <th>Duration</th>
                                <th>Status</th>
                                <th>Created</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="uploadsTableBody">
                            <!-- Data will be loaded via JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="text-center py-4 text-muted" id="noUploadsMessage" style="display: none;">
                    <i class="bi bi-inbox display-4"></i>
                    <p class="mt-2">No uploads yet. Click Upload to add your first recording!</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Upload Modal -->
<div class="modal fade" id="uploadModal" tabindex="-1">
    <div class="modal-dialog modal-lg-custom">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-upload me-2"></i>Upload Recording</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="uploadForm">
                    <div class="mb-3">
                        <label class="form-label fw-bold">
                            <i class="bi bi-file-earmark-music me-1"></i>Upload Audio/Video File
                        </label>
                        <input type="file" class="form-control" name="file" id="fileInput"
                               accept=".mp3,.mp4,.wav,.webm,.m4a,.ogg,.flac">
                        <div class="form-text">
                            Supported formats: MP3, MP4, WAV, WebM, M4A, OGG, FLAC (max 500MB)
                        </div>
                    </div>

                    <div class="text-center my-3">
                        <span class="bg-white px-3 text-muted">OR</span>
                        <hr class="mt-n3">
                    </div>

                    <div class="mb-3">
                        <label class="form-label fw-bold">
                            <i class="bi bi-link-45deg me-1"></i>Enter URL (YouTube, etc.)
                        </label>
                        <input type="url" class="form-control" name="url" id="urlInput"
                               placeholder="https://youtube.com/watch?v=...">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="uploadSubmitBtn">
                    <i class="bi bi-upload me-1"></i>Upload
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Transcribe Modal -->
<div class="modal fade" id="transcribeModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-soundwave me-2"></i>Transcribe</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="transcribeUploadId">
                <div class="mb-3">
                    <label class="form-label fw-bold">Provider</label>
                    <select class="form-select" id="transcribeProvider">
                        <option value="whisper">OpenAI Whisper</option>
                        <option value="faster-whisper">Faster Whisper</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label class="form-label fw-bold">Model</label>
                    <select class="form-select" id="transcribeModel">
                        <!-- Models will be populated dynamically -->
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="transcribeSubmitBtn">
                    <i class="bi bi-play-fill me-1"></i>Start Transcription
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Format Modal -->
<div class="modal fade" id="formatModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-magic me-2"></i>Format</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="formatTranscribeId">
                <div class="mb-3">
                    <label class="form-label fw-bold">Provider</label>
                    <select class="form-select" id="formatProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Google Gemini</option>
                        <option value="lmstudio">LM Studio (Local)</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label class="form-label fw-bold">Model</label>
                    <select class="form-select" id="formatModel">
                        <!-- Models will be populated dynamically -->
                    </select>
                </div>
                <div class="mb-3" id="contextWindowGroup" style="display: none;">
                    <label class="form-label fw-bold">Context Window Size</label>
                    <div class="d-flex align-items-center gap-3">
                        <input type="range" class="form-range flex-grow-1" id="formatContextSlider"
                               min="2048" max="1048576" step="1024" value="8192">
                        <span class="badge bg-primary" id="contextWindowDisplay" style="min-width: 80px;">8K</span>
                    </div>
                    <div class="d-flex justify-content-between mt-1">
                        <small class="text-muted">2K</small>
                        <small class="text-muted" id="sliderMaxLabel">1M</small>
                    </div>
                    <div class="mt-2">
                        <label class="form-label small text-muted mb-1">Quick presets:</label>
                        <div class="btn-group btn-group-sm w-100" role="group">
                            <button type="button" class="btn btn-outline-secondary context-preset" data-value="4096">4K</button>
                            <button type="button" class="btn btn-outline-secondary context-preset" data-value="8192">8K</button>
                            <button type="button" class="btn btn-outline-secondary context-preset" data-value="16384">16K</button>
                            <button type="button" class="btn btn-outline-secondary context-preset" data-value="32768">32K</button>
                            <button type="button" class="btn btn-outline-secondary context-preset" data-value="65536">64K</button>
                            <button type="button" class="btn btn-outline-secondary context-preset" data-value="131072">128K</button>
                        </div>
                    </div>
                    <div class="mt-2 p-2 bg-light rounded" id="tokenInfoPanel">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="small">Model context:</span>
                            <span class="small fw-bold" id="modelContextDisplay">-</span>
                        </div>
                        <div class="d-flex justify-content-between align-items-center mt-1">
                            <span class="small">Selected:</span>
                            <span class="small fw-bold" id="selectedContextDisplay">8,192 tokens</span>
                        </div>
                        <div class="progress mt-2" style="height: 6px;">
                            <div class="progress-bar" id="contextUsageBar" style="width: 50%;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="formatSubmitBtn">
                    <i class="bi bi-play-fill me-1"></i>Start Formatting
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Progress Modal -->
<div class="modal fade" id="progressModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="progressModalTitle">Processing...</h5>
            </div>
            <div class="modal-body">
                <div id="progressContent">
                    <div class="text-center py-4">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div class="progress mb-3" style="height: 25px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated"
                                 role="progressbar" id="progressBar" style="width: 0%">
                                <span id="progressText">0%</span>
                            </div>
                        </div>
                        <p class="text-muted" id="progressStatus">Initializing...</p>
                    </div>
                </div>
                <div id="streamingContent" style="display: none;">
                    <div class="streaming-text" id="streamingText"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- View Text Modal -->
<div class="modal fade" id="viewTextModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="viewTextTitle">View Text</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <pre class="streaming-text" id="viewTextContent" style="max-height: 70vh;"></pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Compare Modal -->
<div class="modal fade" id="compareModal" tabindex="-1">
    <div class="modal-dialog modal-fullscreen">
        <div class="modal-content">
            <div class="modal-header">
                <div class="d-flex align-items-center gap-3 flex-wrap">
                    <h5 class="modal-title mb-0" id="compareModalTitle">Compare Texts</h5>
                    <div id="compareButtonsRow" class="d-flex gap-2 flex-wrap"></div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-3" style="overflow-y: auto;">
                <div id="diffContainer">
                    <div class="text-center text-muted py-5" id="diffPlaceholder">
                        Select items to compare using the buttons above (2-4 items)
                    </div>
                    <div class="d-none" id="sideBySideContainer">
                        <div class="row g-2" id="sideBySidePanels" style="height: calc(100vh - 150px);">
                            <!-- Panels will be dynamically inserted here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
// Global state
let providersConfig = {};
let uploadsData = [];
let userPreferences = { transcribe: {}, format: {} };

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    loadProviders();
    loadUploads();
    loadPreferences();
    setupEventListeners();
});

// Load provider configuration
async function loadProviders() {
    try {
        const response = await fetch('/api/config/providers');
        providersConfig = await response.json();
        updateTranscribeModels();
        updateFormatModels();
    } catch (error) {
        console.error('Error loading providers:', error);
    }
}

// Load user preferences
async function loadPreferences() {
    try {
        const response = await fetch('/api/config/preferences');
        userPreferences = await response.json();
    } catch (error) {
        console.error('Error loading preferences:', error);
    }
}

// Load all uploads
async function loadUploads() {
    try {
        const response = await fetch('/api/uploads');
        uploadsData = await response.json();
        renderUploadsTable();
    } catch (error) {
        console.error('Error loading uploads:', error);
    }
}

// Render uploads table
function renderUploadsTable() {
    const tbody = document.getElementById('uploadsTableBody');
    const noUploadsMsg = document.getElementById('noUploadsMessage');

    if (uploadsData.length === 0) {
        tbody.innerHTML = '';
        noUploadsMsg.style.display = 'block';
        return;
    }

    noUploadsMsg.style.display = 'none';

    let html = '';
    uploadsData.forEach(upload => {
        const hasTranscribes = upload.transcribes && upload.transcribes.length > 0;
        const isIndexed = upload.is_indexed;
        const rowClass = isIndexed ? 'indexed-row' : (hasIndexedChild(upload) ? 'has-indexed-child' : '');

        html += `
            <tr class="${rowClass}" data-upload-id="${upload.id}">
                <td class="expand-btn" onclick="toggleExpand(this, ${upload.id})">
                    ${hasTranscribes ? '<i class="bi bi-chevron-right"></i>' : ''}
                </td>
                <td>
                    <i class="bi bi-file-earmark-music me-1"></i>
                    ${escapeHtml(upload.original_filename || upload.filename)}
                    ${upload.source_url ? `<br><small class="text-muted"><i class="bi bi-link-45deg"></i> ${escapeHtml(upload.source_url.substring(0, 50))}...</small>` : ''}
                </td>
                <td>${formatDuration(upload.duration_seconds)}</td>
                <td>
                    ${isIndexed ? '<span class="badge bg-success"><i class="bi bi-check-circle"></i> Indexed</span>' :
                      hasTranscribes ? '<span class="badge bg-info">Has Transcriptions</span>' :
                      '<span class="badge bg-secondary">Pending</span>'}
                </td>
                <td>${formatDate(upload.created_at)}</td>
                <td>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-primary action-btn" onclick="openTranscribeModal(${upload.id})" title="Transcribe">
                            <i class="bi bi-soundwave"></i>
                        </button>
                        ${hasMultipleCompletedTranscribes(upload) ? `
                            <button class="btn btn-outline-info action-btn" onclick="openCompareModal('transcribe', ${upload.id})" title="Compare Transcriptions">
                                <i class="bi bi-file-diff"></i>
                            </button>
                        ` : ''}
                        ${isIndexed ? `
                            <button class="btn btn-outline-danger action-btn" onclick="removeIndex(${upload.id})" title="Remove Index">
                                <i class="bi bi-x-circle"></i>
                            </button>
                        ` : ''}
                        <button class="btn btn-outline-danger action-btn" onclick="deleteUpload(${upload.id})" title="Delete">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;

        // Add nested transcriptions row
        if (hasTranscribes) {
            html += `
                <tr class="nested-table" id="transcribes-${upload.id}">
                    <td colspan="6" class="p-0">
                        <div class="child-table">
                            <table class="table table-sm mb-0">
                                <thead class="table-secondary">
                                    <tr>
                                        <th style="width: 30px;"></th>
                                        <th>Provider/Model</th>
                                        <th>Duration</th>
                                        <th>Status</th>
                                        <th>Created</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${renderTranscribes(upload.transcribes, upload.id)}
                                </tbody>
                            </table>
                        </div>
                    </td>
                </tr>
            `;
        }
    });

    tbody.innerHTML = html;
}

function renderTranscribes(transcribes, uploadId) {
    let html = '';
    const completedTranscribes = transcribes.filter(t => t.status === 'completed' && t.text);
    const hasMultipleTranscribes = completedTranscribes.length > 1;


    transcribes.forEach(t => {
        const hasContents = t.contents && t.contents.length > 0;
        const hasIndexedContent = t.contents?.some(c => c.is_indexed);
        const rowClass = hasIndexedContent ? 'has-indexed-child' : '';

        html += `
            <tr class="${rowClass}" data-transcribe-id="${t.id}">
                <td class="expand-btn" onclick="toggleTranscribeExpand(this, ${t.id})">
                    ${hasContents ? '<i class="bi bi-chevron-right"></i>' : ''}
                </td>
                <td>
                    <strong>${escapeHtml(t.provider)}</strong> / ${escapeHtml(t.model)}
                </td>
                <td>${formatDuration(t.duration_seconds)}</td>
                <td>
                    ${renderStatus(t.status, t.progress)}
                </td>
                <td>${formatDate(t.created_at)}</td>
                <td>
                    <div class="btn-group btn-group-sm">
                        ${t.status === 'completed' && t.text ? `
                            <button class="btn btn-outline-info action-btn" onclick="viewTextById('transcribe', ${t.id})" title="View">
                                <i class="bi bi-eye"></i>
                            </button>
                            <button class="btn btn-outline-primary action-btn" onclick="openFormatModal(${t.id})" title="Format">
                                <i class="bi bi-magic"></i>
                            </button>
                            ${hasMultipleCompletedContents(t) ? `
                                <button class="btn btn-outline-success action-btn" onclick="openCompareModal('content', ${t.id})" title="Compare Formattings">
                                    <i class="bi bi-file-diff"></i>
                                </button>
                            ` : ''}
                        ` : ''}
                        ${t.status === 'processing' ? `
                            <button class="btn btn-outline-warning action-btn" onclick="checkTranscriptionStatus(${t.id})" title="Check Status">
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        ` : ''}
                        <button class="btn btn-outline-danger action-btn" onclick="deleteTranscription(${t.id})" title="Delete">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;

        // Add nested contents row
        if (hasContents) {
            html += `
                <tr class="nested-table" id="contents-${t.id}">
                    <td colspan="6" class="p-0">
                        <div class="child-table">
                            <table class="table table-sm mb-0">
                                <thead class="table-light">
                                    <tr>
                                        <th>Provider/Model</th>
                                        <th>Duration</th>
                                        <th>Status</th>
                                        <th>Indexed</th>
                                        <th>Created</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${renderContents(t.contents, t.id)}
                                </tbody>
                            </table>
                        </div>
                    </td>
                </tr>
            `;
        }
    });
    return html;
}

function renderContents(contents, transcribeId) {
    let html = '';

    contents.forEach(c => {
        const rowClass = c.is_indexed ? 'indexed-row' : '';

        html += `
            <tr class="${rowClass}" data-content-id="${c.id}">
                <td>
                    <strong>${escapeHtml(c.provider)}</strong> / ${escapeHtml(c.model)}
                </td>
                <td>${formatDuration(c.duration_seconds)}</td>
                <td>
                    ${renderStatus(c.status, c.progress)}
                </td>
                <td>
                    ${c.is_indexed ? '<span class="badge bg-success"><i class="bi bi-check"></i></span>' : '<span class="badge bg-secondary">No</span>'}
                </td>
                <td>${formatDate(c.created_at)}</td>
                <td>
                    <div class="btn-group btn-group-sm">
                        ${c.status === 'completed' && c.text ? `
                            <button class="btn btn-outline-info action-btn" onclick="viewTextById('content', ${c.id})" title="View">
                                <i class="bi bi-eye"></i>
                            </button>
                            <button class="btn btn-outline-primary action-btn" onclick="downloadContent(${c.id})" title="Download">
                                <i class="bi bi-download"></i>
                            </button>
                            ${!c.is_indexed ? `
                                <button class="btn btn-outline-success action-btn" onclick="indexContent(${c.id})" title="Index">
                                    <i class="bi bi-database-add"></i>
                                </button>
                            ` : ''}
                        ` : ''}
                        <button class="btn btn-outline-danger action-btn" onclick="deleteContent(${c.id})" title="Delete">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    });
    return html;
}

function renderStatus(status, progress) {
    if (status === 'processing') {
        return `
            <div class="progress-container">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated"
                         style="width: ${progress || 0}%">${Math.round(progress || 0)}%</div>
                </div>
            </div>
        `;
    }
    const statusClasses = {
        'pending': 'bg-secondary',
        'completed': 'bg-success',
        'error': 'bg-danger'
    };
    return `<span class="badge ${statusClasses[status] || 'bg-secondary'}">${status}</span>`;
}

function hasIndexedChild(upload) {
    if (!upload.transcribes) return false;
    for (const t of upload.transcribes) {
        if (t.contents) {
            for (const c of t.contents) {
                if (c.is_indexed) return true;
            }
        }
    }
    return false;
}

function hasMultipleCompletedTranscribes(upload) {
    if (!upload.transcribes) return false;
    const completed = upload.transcribes.filter(t => t.status === 'completed' && t.text);
    return completed.length > 1;
}

function hasMultipleCompletedContents(transcribe) {
    if (!transcribe.contents) return false;
    const completed = transcribe.contents.filter(c => c.status === 'completed' && c.text);
    return completed.length > 1;
}

// Toggle expand/collapse
function toggleExpand(btn, uploadId) {
    const row = document.getElementById(`transcribes-${uploadId}`);
    if (row) {
        row.classList.toggle('show');
        btn.classList.toggle('expanded');
    }
}

function toggleTranscribeExpand(btn, transcribeId) {
    const row = document.getElementById(`contents-${transcribeId}`);
    if (row) {
        row.classList.toggle('show');
        btn.classList.toggle('expanded');
    }
}

// Setup event listeners
function setupEventListeners() {
    // Upload form
    document.getElementById('uploadSubmitBtn').addEventListener('click', handleUpload);

    // Transcribe form
    document.getElementById('transcribeProvider').addEventListener('change', updateTranscribeModels);
    document.getElementById('transcribeSubmitBtn').addEventListener('click', handleTranscribe);

    // Format form
    document.getElementById('formatProvider').addEventListener('change', updateFormatModels);
    document.getElementById('formatSubmitBtn').addEventListener('click', handleFormat);

    // Context window slider
    document.getElementById('formatContextSlider').addEventListener('input', updateContextSliderDisplay);

    // Context preset buttons
    document.querySelectorAll('.context-preset').forEach(btn => {
        btn.addEventListener('click', function() {
            const value = parseInt(this.dataset.value);
            const slider = document.getElementById('formatContextSlider');
            const maxVal = parseInt(slider.max);
            if (value <= maxVal) {
                slider.value = value;
                updateContextSliderDisplay();
                // Highlight the selected preset
                document.querySelectorAll('.context-preset').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            }
        });
    });

    // Refresh button
    document.getElementById('refreshBtn').addEventListener('click', loadUploads);

    // Search
    document.getElementById('searchBtn').addEventListener('click', handleSearch);
    document.getElementById('searchInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') handleSearch();
    });
    document.getElementById('clearSearch').addEventListener('click', function() {
        document.getElementById('searchResults').style.display = 'none';
        document.getElementById('searchInput').value = '';
    });
}

// Update model dropdowns
function updateTranscribeModels() {
    const providerSelect = document.getElementById('transcribeProvider');
    const provider = providerSelect.value;
    const modelSelect = document.getElementById('transcribeModel');
    const models = providersConfig.transcribe?.[provider]?.models || [];

    modelSelect.innerHTML = models.map(m =>
        `<option value="${m}">${m}${getModelDescription(provider, m)}</option>`
    ).join('');

    // Select last used model for this provider if available
    const savedModel = userPreferences.transcribe?.model;
    const savedProvider = userPreferences.transcribe?.provider;
    if (savedProvider === provider && savedModel && models.includes(savedModel)) {
        modelSelect.value = savedModel;
    }
}

function updateFormatModels() {
    const provider = document.getElementById('formatProvider').value;
    const modelSelect = document.getElementById('formatModel');
    const contextWindowGroup = document.getElementById('contextWindowGroup');
    const models = providersConfig.format?.[provider]?.models || [];
    const modelsInfo = providersConfig.format?.[provider]?.models_info || [];

    if (models.length === 0 && provider === 'lmstudio') {
        modelSelect.innerHTML = '<option value="">No models available - Start LM Studio</option>';
    } else {
        modelSelect.innerHTML = models.map(m => {
            const info = modelsInfo.find(i => i.id === m);
            const contextStr = info ? ` (${formatTokenCount(info.context_length)})` : '';
            return `<option value="${m}" data-context="${info?.context_length || 0}">${m}${contextStr}</option>`;
        }).join('');
    }

    // Select last used model for this provider if available
    const savedModel = userPreferences.format?.model;
    const savedProvider = userPreferences.format?.provider;
    if (savedProvider === provider && savedModel && models.includes(savedModel)) {
        modelSelect.value = savedModel;
    }

    // Show/hide context window selector for LM Studio
    if (provider === 'lmstudio') {
        contextWindowGroup.style.display = 'block';
        // Restore last selected context window size
        const savedContextWindow = localStorage.getItem('lmstudio_context_window');
        const slider = document.getElementById('formatContextSlider');
        if (savedContextWindow) {
            slider.value = savedContextWindow;
        }
        updateContextSliderDisplay();
        updateModelContextInfo();

        // Add change listener for model select
        modelSelect.onchange = updateModelContextInfo;
    } else {
        contextWindowGroup.style.display = 'none';
    }
}

function formatTokenCount(tokens) {
    if (tokens >= 1000000) return (tokens / 1000000).toFixed(1) + 'M';
    if (tokens >= 1000) return Math.round(tokens / 1000) + 'K';
    return tokens.toString();
}

function updateContextSliderDisplay() {
    const slider = document.getElementById('formatContextSlider');
    const display = document.getElementById('contextWindowDisplay');
    const selectedDisplay = document.getElementById('selectedContextDisplay');
    const value = parseInt(slider.value);

    display.textContent = formatTokenCount(value);
    selectedDisplay.textContent = value.toLocaleString() + ' tokens';

    updateContextUsageBar();
}

function updateModelContextInfo() {
    const modelSelect = document.getElementById('formatModel');
    const selectedOption = modelSelect.options[modelSelect.selectedIndex];
    const modelContext = parseInt(selectedOption?.dataset?.context) || 0;
    const modelContextDisplay = document.getElementById('modelContextDisplay');
    const sliderMaxLabel = document.getElementById('sliderMaxLabel');

    if (modelContext > 0) {
        modelContextDisplay.textContent = modelContext.toLocaleString() + ' tokens';
    } else {
        modelContextDisplay.textContent = 'Unknown';
    }

    // Update slider max based on model context
    const slider = document.getElementById('formatContextSlider');
    if (modelContext > 0) {
        slider.max = modelContext;
        // Update the max label to show the actual max
        sliderMaxLabel.textContent = formatTokenCount(modelContext);
        // If current value exceeds model max, adjust it
        if (parseInt(slider.value) > modelContext) {
            slider.value = modelContext;
            updateContextSliderDisplay();
        }
    } else {
        // Default to 128K if no model context info
        slider.max = 131072;
        sliderMaxLabel.textContent = '128K';
    }

    updateContextUsageBar();
}

function updateContextUsageBar() {
    const slider = document.getElementById('formatContextSlider');
    const modelSelect = document.getElementById('formatModel');
    const selectedOption = modelSelect.options[modelSelect.selectedIndex];
    const modelContext = parseInt(selectedOption?.dataset?.context) || parseInt(slider.max);
    const selectedContext = parseInt(slider.value);

    const usageBar = document.getElementById('contextUsageBar');
    const percentage = modelContext > 0 ? (selectedContext / modelContext) * 100 : 50;
    usageBar.style.width = percentage + '%';

    // Color based on usage
    if (percentage > 80) {
        usageBar.className = 'progress-bar bg-warning';
    } else {
        usageBar.className = 'progress-bar bg-primary';
    }
}

function getModelDescription(provider, model) {
    const descriptions = {
        'tiny': ' (Fastest, less accurate)',
        'base': ' (Fast, good accuracy)',
        'small': ' (Balanced)',
        'medium': ' (Slower, better accuracy)',
        'large': ' (Slowest, best accuracy)',
        'large-v2': ' (Best accuracy v2)',
        'large-v3': ' (Best accuracy v3)'
    };
    return descriptions[model] || '';
}

// Handle upload
async function handleUpload() {
    const fileInput = document.getElementById('fileInput');
    const urlInput = document.getElementById('urlInput');

    if (!fileInput.files[0] && !urlInput.value) {
        alert('Please select a file or enter a URL');
        return;
    }

    const formData = new FormData();
    if (fileInput.files[0]) {
        formData.append('file', fileInput.files[0]);
    } else {
        formData.append('url', urlInput.value);
    }

    try {
        showProgress('Uploading...', 'Preparing your file...');

        const response = await fetch('/api/uploads', {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Upload failed');
        }

        hideProgress();
        bootstrap.Modal.getInstance(document.getElementById('uploadModal')).hide();
        document.getElementById('uploadForm').reset();
        loadUploads();

    } catch (error) {
        hideProgress();
        alert('Error: ' + error.message);
    }
}

// Open transcribe modal
function openTranscribeModal(uploadId) {
    document.getElementById('transcribeUploadId').value = uploadId;

    // Apply saved provider preference
    const providerSelect = document.getElementById('transcribeProvider');
    if (userPreferences.transcribe?.provider) {
        providerSelect.value = userPreferences.transcribe.provider;
    }

    updateTranscribeModels();
    new bootstrap.Modal(document.getElementById('transcribeModal')).show();
}

// Handle transcription
async function handleTranscribe() {
    const uploadId = document.getElementById('transcribeUploadId').value;
    const provider = document.getElementById('transcribeProvider').value;
    const model = document.getElementById('transcribeModel').value;

    // Save preferences
    saveTranscribePreferences(provider, model);

    try {
        const response = await fetch('/api/transcribe', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({upload_id: parseInt(uploadId), provider, model})
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Transcription failed');
        }

        const result = await response.json();
        bootstrap.Modal.getInstance(document.getElementById('transcribeModal')).hide();

        // Show progress modal and poll for status
        showTranscriptionProgress(result.id);

    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Save transcribe preferences
async function saveTranscribePreferences(provider, model) {
    try {
        await fetch('/api/config/preferences/transcribe', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({provider, model})
        });
        // Update local state
        userPreferences.transcribe = {provider, model};
    } catch (error) {
        console.error('Error saving transcribe preferences:', error);
    }
}

// Show transcription progress
async function showTranscriptionProgress(transcribeId) {
    showProgress('Transcribing...', 'This may take several minutes...');

    const pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/transcribe/${transcribeId}/status`);
            const status = await response.json();

            updateProgressBar(status.progress || 0);
            document.getElementById('progressStatus').textContent =
                `Status: ${status.status} - ${Math.round(status.progress || 0)}%`;

            if (status.status === 'completed' || status.status === 'error') {
                clearInterval(pollInterval);
                hideProgress();
                loadUploads();

                if (status.status === 'error') {
                    alert('Transcription error: ' + (status.error_message || 'Unknown error'));
                }
            }
        } catch (error) {
            clearInterval(pollInterval);
            hideProgress();
            alert('Error checking status: ' + error.message);
        }
    }, 2000);
}

// Check transcription status
async function checkTranscriptionStatus(transcribeId) {
    showTranscriptionProgress(transcribeId);
}

// Open format modal
function openFormatModal(transcribeId) {
    document.getElementById('formatTranscribeId').value = transcribeId;

    // Apply saved provider preference
    const providerSelect = document.getElementById('formatProvider');
    if (userPreferences.format?.provider) {
        providerSelect.value = userPreferences.format.provider;
    }

    updateFormatModels();
    new bootstrap.Modal(document.getElementById('formatModal')).show();
}

// Handle formatting
async function handleFormat() {
    const transcribeId = document.getElementById('formatTranscribeId').value;
    const provider = document.getElementById('formatProvider').value;
    const model = document.getElementById('formatModel').value;

    // Save preferences
    saveFormatPreferences(provider, model);

    // Build request body
    const requestBody = {transcribe_id: parseInt(transcribeId), provider, model};

    // Add context window for LM Studio and save to localStorage
    if (provider === 'lmstudio') {
        const contextWindow = document.getElementById('formatContextSlider').value;
        requestBody.context_length = parseInt(contextWindow);
        localStorage.setItem('lmstudio_context_window', contextWindow);

        // Unload all models and load the selected one with context
        try {
            showProgress('Loading Model...', 'Unloading previous models...');
            await fetch('/api/lmstudio/unload', { method: 'POST' });

            document.getElementById('progressStatus').textContent = 'Loading model with ' + formatTokenCount(parseInt(contextWindow)) + ' context...';
            await fetch('/api/lmstudio/load', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    model_id: model,
                    context_length: parseInt(contextWindow)
                })
            });
            hideProgress();
        } catch (e) {
            console.warn('Could not reload model:', e);
            hideProgress();
        }
    }

    try {
        const response = await fetch('/api/format', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Formatting failed');
        }

        const result = await response.json();
        bootstrap.Modal.getInstance(document.getElementById('formatModal')).hide();

        // Show formatting progress
        showFormatProgress(result.id);

    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Save format preferences
async function saveFormatPreferences(provider, model) {
    try {
        await fetch('/api/config/preferences/format', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({provider, model})
        });
        // Update local state
        userPreferences.format = {provider, model};
    } catch (error) {
        console.error('Error saving format preferences:', error);
    }
}

// Show format progress
async function showFormatProgress(contentId) {
    showProgress('Formatting...', 'Processing with LLM...');

    const pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/format/${contentId}/status`);
            const status = await response.json();

            if (status.status === 'completed' || status.status === 'error') {
                clearInterval(pollInterval);
                hideProgress();
                loadUploads();

                if (status.status === 'error') {
                    alert('Formatting error: ' + (status.error_message || 'Unknown error'));
                }
            }
        } catch (error) {
            clearInterval(pollInterval);
            hideProgress();
            alert('Error checking status: ' + error.message);
        }
    }, 2000);
}

// Index content
async function indexContent(contentId) {
    try {
        showProgress('Indexing...', 'Adding to vector database...');

        const response = await fetch('/api/index', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({content_id: contentId})
        });

        hideProgress();

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Indexing failed');
        }

        loadUploads();

    } catch (error) {
        hideProgress();
        alert('Error: ' + error.message);
    }
}

// Remove index
async function removeIndex(uploadId) {
    if (!confirm('Remove this upload from the search index?')) return;

    try {
        const response = await fetch(`/api/index/${uploadId}`, {method: 'DELETE'});

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to remove index');
        }

        loadUploads();

    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Delete operations
async function deleteUpload(uploadId) {
    if (!confirm('Delete this upload and all related data?')) return;

    try {
        const response = await fetch(`/api/uploads/${uploadId}`, {method: 'DELETE'});

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Delete failed');
        }

        loadUploads();

    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function deleteTranscription(transcribeId) {
    if (!confirm('Delete this transcription and all formatted content?')) return;

    try {
        const response = await fetch(`/api/transcribe/${transcribeId}`, {method: 'DELETE'});

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Delete failed');
        }

        loadUploads();

    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function deleteContent(contentId) {
    if (!confirm('Delete this formatted content?')) return;

    try {
        const response = await fetch(`/api/format/${contentId}`, {method: 'DELETE'});

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Delete failed');
        }

        loadUploads();

    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// View text
function viewText(title, text) {
    document.getElementById('viewTextTitle').textContent = title;
    document.getElementById('viewTextContent').textContent = text;
    new bootstrap.Modal(document.getElementById('viewTextModal')).show();
}

// View text by fetching from API (avoids JS escaping issues)
async function viewTextById(type, id) {
    try {
        let response;
        let title;
        if (type === 'transcribe') {
            response = await fetch(`/api/transcribe/${id}/status`);
            title = 'Transcription';
        } else {
            response = await fetch(`/api/format/${id}/status`);
            title = 'Formatted Content';
        }

        if (!response.ok) throw new Error('Failed to load text');

        const data = await response.json();
        document.getElementById('viewTextTitle').textContent = title;
        document.getElementById('viewTextContent').textContent = data.text || 'No text available';
        new bootstrap.Modal(document.getElementById('viewTextModal')).show();
    } catch (error) {
        alert('Error loading text: ' + error.message);
    }
}

// Download content as .txt file
async function downloadContent(contentId) {
    try {
        const response = await fetch(`/api/format/${contentId}/status`);
        if (!response.ok) throw new Error('Failed to load content');

        const data = await response.json();
        if (!data.text) {
            alert('No text available to download');
            return;
        }

        // Create a blob with the text content
        const blob = new Blob([data.text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        // Create download link and trigger download
        const a = document.createElement('a');
        a.href = url;
        a.download = `formatted_content_${contentId}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    } catch (error) {
        alert('Error downloading content: ' + error.message);
    }
}

// Search
async function handleSearch() {
    const query = document.getElementById('searchInput').value.trim();
    if (!query) return;

    try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
        const results = await response.json();

        const resultsDiv = document.getElementById('searchResults');
        const resultsBody = document.getElementById('searchResultsBody');

        if (results.length === 0) {
            resultsBody.innerHTML = '<p class="text-muted">No results found.</p>';
        } else {
            resultsBody.innerHTML = results.map(r => `
                <div class="card mb-2">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <strong>${escapeHtml(r.upload.filename)}</strong>
                                ${r.score ? `<span class="badge bg-success ms-2">${Math.round(r.score * 100)}% match</span>` : ''}
                            </div>
                            <small class="text-muted">${formatDate(r.upload.created_at)}</small>
                        </div>
                        <p class="mb-0 mt-1 small text-muted">${escapeHtml(r.snippet)}</p>
                    </div>
                </div>
            `).join('');
        }

        resultsDiv.style.display = 'block';

    } catch (error) {
        alert('Search error: ' + error.message);
    }
}

// Progress modal helpers
function showProgress(title, status) {
    document.getElementById('progressModalTitle').textContent = title;
    document.getElementById('progressStatus').textContent = status;
    document.getElementById('progressContent').style.display = 'block';
    document.getElementById('streamingContent').style.display = 'none';
    updateProgressBar(0);
    new bootstrap.Modal(document.getElementById('progressModal')).show();
}

function hideProgress() {
    const modal = bootstrap.Modal.getInstance(document.getElementById('progressModal'));
    if (modal) modal.hide();
}

function updateProgressBar(percent) {
    const bar = document.getElementById('progressBar');
    const text = document.getElementById('progressText');
    bar.style.width = `${percent}%`;
    text.textContent = `${Math.round(percent)}%`;
}

// Utility functions
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDuration(seconds) {
    if (!seconds) return '-';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function formatDate(isoString) {
    if (!isoString) return '-';
    const date = new Date(isoString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
}

// ============ Compare Functionality ============
let compareState = {
    type: null,  // 'transcribe' or 'content'
    parentId: null,
    items: [],
    selectedIndices: []  // Array of selected indices (2-4 items)
};

async function openCompareModal(type, parentId) {
    compareState.type = type;
    compareState.parentId = parentId;
    compareState.items = [];
    compareState.selectedIndices = [];

    // Get items to compare
    if (type === 'transcribe') {
        // Find upload and get its transcribes
        const upload = uploadsData.find(u => u.id === parentId);
        if (upload) {
            compareState.items = upload.transcribes.filter(t => t.status === 'completed' && t.text);
        }
        document.getElementById('compareModalTitle').textContent = 'Compare Transcriptions';
    } else {
        // Find transcribe and get its contents
        for (const upload of uploadsData) {
            const transcribe = upload.transcribes?.find(t => t.id === parentId);
            if (transcribe) {
                // Add raw transcribe as first item
                compareState.items = [{
                    id: transcribe.id,
                    provider: 'Transcribe',
                    model: '',
                    text: transcribe.text,
                    isRawTranscribe: true
                }];
                // Add formatted contents
                compareState.items.push(...transcribe.contents.filter(c => c.status === 'completed' && c.text));
                break;
            }
        }
        document.getElementById('compareModalTitle').textContent = 'Compare Formattings';
    }

    renderCompareButtons();
    resetDiffView();

    new bootstrap.Modal(document.getElementById('compareModal')).show();
}

function renderCompareButtons() {
    const container = document.getElementById('compareButtonsRow');
    let html = '';

    compareState.items.forEach((item, index) => {
        const isSelected = compareState.selectedIndices.includes(index);
        const selectionOrder = compareState.selectedIndices.indexOf(index) + 1;
        let btnClass = isSelected ? 'btn-primary' : 'btn-outline-secondary';
        let selectedClass = isSelected ? 'selected' : '';

        html += `
            <button class="btn btn-sm ${btnClass} compare-btn ${selectedClass}" onclick="selectCompareItem(${index})">
                ${isSelected ? `<span class="badge bg-light text-dark me-1">${selectionOrder}</span>` : ''}
                ${item.isRawTranscribe ? 'Transcribe' : escapeHtml(item.provider) + '/' + escapeHtml(item.model)}
            </button>
        `;
    });

    // Add clear button if items are selected
    if (compareState.selectedIndices.length > 0) {
        html += `
            <button class="btn btn-sm btn-outline-danger ms-2" onclick="clearCompareSelection()">
                <i class="bi bi-x-circle"></i> Clear
            </button>
        `;
    }

    container.innerHTML = html;
}

function selectCompareItem(index) {
    const existingIndex = compareState.selectedIndices.indexOf(index);

    if (existingIndex !== -1) {
        // Already selected - deselect it
        compareState.selectedIndices.splice(existingIndex, 1);
    } else if (compareState.selectedIndices.length < 4) {
        // Add to selection (max 4)
        compareState.selectedIndices.push(index);
    }

    renderCompareButtons();

    // Show side-by-side view if 2+ items selected
    if (compareState.selectedIndices.length >= 2) {
        showSideBySide();
    } else {
        resetDiffView();
    }
}

function clearCompareSelection() {
    compareState.selectedIndices = [];
    renderCompareButtons();
    resetDiffView();
}

function resetDiffView() {
    document.getElementById('diffPlaceholder').classList.remove('d-none');
    document.getElementById('sideBySideContainer').classList.add('d-none');
}

async function showSideBySide() {
    const selectedItems = compareState.selectedIndices.map(idx => compareState.items[idx]);
    const numPanels = selectedItems.length;

    // Determine column class based on number of panels
    let colClass;
    if (numPanels === 2) colClass = 'col-6';
    else if (numPanels === 3) colClass = 'col-4';
    else colClass = 'col-3';

    // Fetch texts for all selected items
    const texts = [];
    for (const item of selectedItems) {
        let text = item.text;
        if (!text) {
            try {
                const endpoint = item.isRawTranscribe ? '/api/transcribe' : (compareState.type === 'transcribe' ? '/api/transcribe' : '/api/format');
                const resp = await fetch(`${endpoint}/${item.id}/status`);
                const data = await resp.json();
                text = data.text || '';
            } catch (error) {
                text = 'Error loading text';
            }
        }
        texts.push(text);
    }

    // Use first selected as base for highlighting differences
    const baseText = texts[0];

    // Build panels HTML
    let panelsHtml = '';
    for (let i = 0; i < numPanels; i++) {
        const item = selectedItems[i];
        const text = texts[i];
        const label = item.isRawTranscribe ? 'Transcribe' : `${item.provider}/${item.model}`;

        // Highlight differences compared to first panel
        let contentHtml;
        if (i === 0) {
            contentHtml = escapeHtml(text);
        } else {
            contentHtml = computeSideBySideDiff(baseText, text);
        }

        panelsHtml += `
            <div class="${colClass}">
                <div class="compare-panel">
                    <div class="compare-panel-header">
                        <span class="badge bg-primary me-2">${i + 1}</span>
                        ${escapeHtml(label)}
                    </div>
                    <div class="compare-panel-content">${contentHtml}</div>
                </div>
            </div>
        `;
    }

    document.getElementById('sideBySidePanels').innerHTML = panelsHtml;
    document.getElementById('diffPlaceholder').classList.add('d-none');
    document.getElementById('sideBySideContainer').classList.remove('d-none');

    // Sync scroll across panels
    setupSyncScroll();
}

function setupSyncScroll() {
    const panels = document.querySelectorAll('.compare-panel-content');
    let isScrolling = false;

    panels.forEach(panel => {
        panel.addEventListener('scroll', function() {
            if (isScrolling) return;
            isScrolling = true;

            const scrollTop = this.scrollTop;
            const scrollHeight = this.scrollHeight - this.clientHeight;
            const scrollRatio = scrollHeight > 0 ? scrollTop / scrollHeight : 0;

            panels.forEach(otherPanel => {
                if (otherPanel !== this) {
                    const otherScrollHeight = otherPanel.scrollHeight - otherPanel.clientHeight;
                    otherPanel.scrollTop = scrollRatio * otherScrollHeight;
                }
            });

            setTimeout(() => { isScrolling = false; }, 50);
        });
    });
}

function computeSideBySideDiff(baseText, compareText) {
    // Word-level diff highlighting differences from base
    const baseWords = baseText.split(/(\s+)/);
    const compareWords = compareText.split(/(\s+)/);
    const lcs = longestCommonSubsequence(baseWords, compareWords);

    let html = '';
    let ci = 0, lcsIdx = 0;

    while (ci < compareWords.length) {
        if (lcsIdx < lcs.length && compareWords[ci] === lcs[lcsIdx]) {
            // Same as base
            html += escapeHtml(compareWords[ci]);
            ci++;
            lcsIdx++;
        } else {
            // Different from base - highlight as added
            if (compareWords[ci].trim()) {
                html += `<span class="diff-added">${escapeHtml(compareWords[ci])}</span>`;
            } else {
                html += escapeHtml(compareWords[ci]);
            }
            ci++;
        }
    }

    return html;
}

function longestCommonSubsequence(arr1, arr2) {
    const m = arr1.length;
    const n = arr2.length;

    // Create DP table
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (arr1[i - 1] === arr2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Backtrack to find LCS
    const lcs = [];
    let i = m, j = n;
    while (i > 0 && j > 0) {
        if (arr1[i - 1] === arr2[j - 1]) {
            lcs.unshift(arr1[i - 1]);
            i--; j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return lcs;
}
</script>
{% endblock %}

